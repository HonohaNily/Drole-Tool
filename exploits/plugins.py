"""
Plugin exploitation module for MineScan
Handles plugin vulnerability testing and exploitation simulation
"""

import re
from typing import Dict, List, Optional, Tuple

class PluginExploit:
    """Handles plugin vulnerability testing and exploitation"""
    
    def __init__(self, plugins: Dict[str, str], safe_mode: bool = True):
        self.plugins = plugins
        self.safe_mode = safe_mode
        
    def test_plugin_vulnerabilities(self) -> List[Dict]:
        """Test plugins for known vulnerabilities"""
        vulnerabilities = []

        for plugin_name, version in self.plugins.items():
            # Check common plugin vulnerability patterns
            vulns = self._check_common_vulnerabilities(plugin_name, version)
            vulnerabilities.extend(vulns)

            # Check specific plugin vulnerabilities
            specific_vulns = self._check_specific_vulnerabilities(plugin_name, version)
            vulnerabilities.extend(specific_vulns)

            # Add verification details for each vulnerability
            for vuln in vulnerabilities:
                if 'verification' not in vuln:
                    vuln['verification'] = self._get_verification_steps(vuln)

        return vulnerabilities
        
    def _check_common_vulnerabilities(self, plugin_name: str, version: str) -> List[Dict]:
        """Check for common plugin vulnerability patterns"""
        vulns = []
        
        # Common vulnerability patterns
        patterns = [
            {
                'regex': r'backup|export|download',
                'description': 'Potential information disclosure vulnerability',
                'severity': 'MEDIUM'
            },
            {
                'regex': r'upload|import|file',
                'description': 'Potential file upload vulnerability',
                'severity': 'HIGH'
            },
            {
                'regex': r'admin|manage|control',
                'description': 'Administrative interface exposure risk',
                'severity': 'HIGH'
            },
            {
                'regex': r'sql|database|query',
                'description': 'Potential SQL injection vulnerability',
                'severity': 'HIGH'
            }
        ]
        
        for pattern in patterns:
            if re.search(pattern['regex'], plugin_name.lower()):
                vulns.append({
                    'plugin': plugin_name,
                    'version': version,
                    'type': 'common_pattern',
                    'description': pattern['description'],
                    'severity': pattern['severity']
                })
                
        return vulns
        
    def _check_specific_vulnerabilities(self, plugin_name: str, version: str) -> List[Dict]:
        """Check for specific known plugin vulnerabilities"""
        vulns = []
        
        # Known vulnerable plugin versions
        known_vulns = {
            'EssentialsX': {
                'versions': ['<2.18.0'],
                'description': 'Command injection vulnerability in /sudo command',
                'severity': 'CRITICAL'
            },
            'WorldEdit': {
                'versions': ['<7.2.0'],
                'description': 'Arbitrary file read vulnerability',
                'severity': 'HIGH'
            },
            'PermissionsEx': {
                'versions': ['<1.23.4'],
                'description': 'SQL injection in group management',
                'severity': 'HIGH'
            },
            'FlameCord': {
                'versions': ['<1.7.0', '<1.8.0'],
                'description': 'Multiple vulnerabilities in legacy FlameCord versions including potential authentication bypass',
                'severity': 'HIGH'
            },
            'ViaVersion': {
                'versions': ['<4.0.0'],
                'description': 'Protocol manipulation vulnerabilities in older versions',
                'severity': 'HIGH'
            },
            'FastLogin': {
                'versions': ['<1.11'],
                'description': 'Authentication bypass vulnerability in premium verification',
                'severity': 'CRITICAL'
            },
            'Geyser': {
                'versions': ['<2.1.0'],
                'description': 'Cross-platform protocol vulnerabilities',
                'severity': 'HIGH'
            },
            'ProtocolLib': {
                'versions': ['<4.7.0'],
                'description': 'Packet manipulation vulnerabilities',
                'severity': 'HIGH'
            },
            'AuthMe': {
                'versions': ['<5.6.0'],
                'description': 'Authentication bypass vulnerabilities',
                'severity': 'CRITICAL'
            },
            'WorldGuard': {
                'versions': ['<7.0.0'],
                'description': 'Protection bypass vulnerabilities',
                'severity': 'HIGH'
            },
            'CoreProtect': {
                'versions': ['<20.0'],
                'description': 'SQL injection vulnerabilities',
                'severity': 'HIGH'
            },
            'LuckPerms': {
                'versions': ['<5.3.0'],
                'description': 'Permission inheritance vulnerabilities',
                'severity': 'HIGH'
            },
            'Matrix': {
                'versions': ['<6.0.0'],
                'description': 'Anticheat bypass vulnerabilities',
                'severity': 'HIGH'
            },
            'TAB': {
                'versions': ['<3.0.0'],
                'description': 'Information disclosure vulnerabilities',
                'severity': 'MEDIUM'
            },
            'DiscordSRV': {
                'versions': ['<1.25.0'],
                'description': 'Token exposure vulnerabilities',
                'severity': 'HIGH'
            }
        }
        
        if plugin_name in known_vulns:
            vuln_info = known_vulns[plugin_name]
            for vuln_version in vuln_info['versions']:
                if self._check_version_vulnerable(version, vuln_version):
                    vulns.append({
                        'plugin': plugin_name,
                        'version': version,
                        'type': 'known_vulnerability',
                        'description': vuln_info['description'],
                        'severity': vuln_info['severity']
                    })
                    
        return vulns
        
    def _check_version_vulnerable(self, current_version: str, vuln_version: str) -> bool:
        """Check if current version matches vulnerable version pattern"""
        if vuln_version.startswith('<'):
            target_version = vuln_version[1:]
            return self._compare_versions(current_version, target_version) < 0
        elif vuln_version.startswith('<='):
            target_version = vuln_version[2:]
            return self._compare_versions(current_version, target_version) <= 0
        else:
            return current_version == vuln_version
            
    def _compare_versions(self, version1: str, version2: str) -> int:
        """Compare two version strings"""
        v1_parts = [int(x) for x in version1.split('.')]
        v2_parts = [int(x) for x in version2.split('.')]
        
        for i in range(max(len(v1_parts), len(v2_parts))):
            v1 = v1_parts[i] if i < len(v1_parts) else 0
            v2 = v2_parts[i] if i < len(v2_parts) else 0
            
            if v1 < v2:
                return -1
            elif v1 > v2:
                return 1
                
        return 0

    def _get_verification_steps(self, vuln: Dict) -> str:
        """Get specific verification steps for a vulnerability"""
        verification_steps = {
            'FlameCord': """
1. Connect using protocol version 4 (1.7.2 client)
2. Monitor server logs for protocol version warnings
3. Check config.yml for protocol version restrictions
""",
            'FastLogin': """
1. Attempt premium account verification
2. Monitor authentication process
3. Check plugin logs for verification failures
""",
            'Geyser': """
1. Connect using modified Bedrock client
2. Monitor cross-platform protocol handling
3. Check config for protocol validation settings
"""
        }

        for plugin, steps in verification_steps.items():
            if plugin in vuln.get('plugin', ''):
                return steps.strip()

        return "Standard vulnerability verification steps apply"