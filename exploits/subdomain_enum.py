
"""
Subdomain enumeration module for MineScan
Used to discover potential subdomains of Minecraft servers
"""

import concurrent.futures
import dns.resolver
import socket
import time
from typing import List, Optional

class SubdomainEnumerator:
    """Class for enumerating subdomains of a target domain"""
    
    def __init__(self, target: str, threads: int = 10, timeout: int = 2):
        self.target = target
        self.threads = threads
        self.timeout = timeout
        self.discovered_subdomains = set()
        
        # Common subdomains for Minecraft servers
        self.common_subdomains = [
            # Standard web services
            'www', 'web', 'mail', 'smtp', 'pop', 'ns1', 'ns2', 'dns', 
            # Game servers
            'mc', 'play', 'game', 'server', 'srv', 'minecraft', 'mine',
            # Server clusters/types
            'lobby', 'hub', 'survival', 'creative', 'pvp', 'skyblock', 'factions',
            'prison', 'minigames', 'bedwars', 'skywars', 'practice', 'uhc',
            # Infrastructure
            'cdn', 'api', 'stats', 'shop', 'store', 'donate', 'staff', 'admin',
            'bungee', 'proxy', 'dev', 'test', 'build', 'node', 'auth', 'login',
            # Numbered servers
            'mc1', 'mc2', 'mc3', 'server1', 'server2', 'play1', 'play2',
            's1', 's2', 's3', 's4', 'srv1', 'srv2', 'eu', 'us', 'au', 'asia'
        ]
        
    def enumerate_subdomains(self, wordlist: Optional[List[str]] = None) -> List[str]:
        """Enumerate subdomains using common wordlists and DNS queries"""
        if wordlist:
            # Use provided wordlist if available
            self.common_subdomains.extend(wordlist)
        
        # Remove duplicates
        self.common_subdomains = list(set(self.common_subdomains))
        
        print(f"Starting subdomain enumeration for {self.target}")
        print(f"Testing {len(self.common_subdomains)} potential subdomains...")
        
        # Use ThreadPoolExecutor for concurrent subdomain checking
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = [executor.submit(self._check_subdomain, subdomain) 
                      for subdomain in self.common_subdomains]
            
            # Process results as they complete
            for i, future in enumerate(concurrent.futures.as_completed(futures)):
                if i % 10 == 0:
                    print(f"Progress: {i}/{len(self.common_subdomains)} subdomains checked")
                    
        # Convert set to sorted list before returning
        return sorted(list(self.discovered_subdomains))
    
    def _check_subdomain(self, subdomain: str) -> None:
        """Check if a subdomain exists by attempting DNS resolution"""
        full_domain = f"{subdomain}.{self.target}"
        try:
            # Attempt DNS resolution
            answers = dns.resolver.resolve(full_domain, 'A')
            if answers:
                ip_addresses = [answer.address for answer in answers]
                self.discovered_subdomains.add(full_domain)
                print(f"Found subdomain: {full_domain} ({', '.join(ip_addresses)})")
                
                # Also check if this subdomain has a Minecraft server running
                self._check_minecraft_server(full_domain, ip_addresses[0])
        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer, dns.resolver.NoNameservers):
            # Domain doesn't exist or no answer
            pass
        except Exception as e:
            # Other errors
            pass
    
    def _check_minecraft_server(self, domain: str, ip: str) -> None:
        """Check if discovered subdomain is running a Minecraft server"""
        # Common Minecraft server ports
        mc_ports = [25565, 25566, 25567, 25568, 25569, 25570]
        
        for port in mc_ports:
            try:
                # Set a short timeout to avoid hanging
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.timeout)
                
                # Attempt to connect to the port
                result = sock.connect_ex((ip, port))
                if result == 0:
                    print(f"  âœ“ Minecraft server detected on {domain}:{port}")
                    # Add port information to the discovered subdomain
                    self.discovered_subdomains.add(f"{domain}:{port}")
                sock.close()
            except:
                # Ignore connection errors
                pass
