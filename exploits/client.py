
#!/usr/bin/env python3
"""
Minecraft Client module for MineScan
Handles connections to Minecraft servers for security scanning
"""

import socket
import struct
import json
import time
import random
from typing import Dict, List, Optional, Tuple

class MinecraftClient:
    """Client for connecting to Minecraft servers and testing vulnerabilities"""

    def __init__(self, host: str, port: int = 25565, timeout: int = 10):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.socket = None
        self.protocol_version = 47  # Default to 1.8.9 protocol
        self.connected = False
        self.logged_in = False

    def connect(self) -> bool:
        """Establish connection to the Minecraft server"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(self.timeout)
            self.socket.connect((self.host, self.port))
            self.connected = True
            return True
        except Exception as e:
            print(f"Connection failed: {str(e)}")
            self.connected = False
            return False

    def close(self):
        """Close the connection to the server"""
        if self.socket:
            try:
                self.socket.close()
            except:
                pass
        self.connected = False
        self.logged_in = False

    def _send_packet(self, packet_id: int, data: bytes) -> bool:
        """Send a packet to the server"""
        if not self.connected or not self.socket:
            return False

        try:
            # Packet format: Length (VarInt) + Packet ID (VarInt) + Data
            packet_data = self._pack_varint(packet_id) + data
            packet = self._pack_varint(len(packet_data)) + packet_data
            
            self.socket.sendall(packet)
            return True
        except Exception as e:
            print(f"Failed to send packet: {str(e)}")
            return False

    def _read_packet(self) -> Optional[Tuple[int, bytes]]:
        """Read a packet from the server"""
        if not self.connected or not self.socket:
            return None

        try:
            # Read packet length
            length_buffer = bytearray()
            while True:
                byte = self.socket.recv(1)
                if not byte:
                    return None
                length_buffer.append(byte[0])
                if byte[0] & 0x80 == 0:
                    break

            # Parse length as VarInt
            length, _ = self._read_varint(length_buffer, 0)
            
            # Read packet data
            data = self.socket.recv(length)
            if not data:
                return None

            # Parse packet ID as VarInt
            packet_id, pos = self._read_varint(data, 0)
            
            return packet_id, data[pos:]
        except socket.timeout:
            print("Socket timeout while reading packet")
            return None
        except Exception as e:
            print(f"Failed to read packet: {str(e)}")
            return None

    def _pack_varint(self, val: int) -> bytes:
        """Pack a variable-length integer"""
        result = bytearray()
        while True:
            byte = val & 0x7F
            val >>= 7
            if val:
                byte |= 0x80
            result.append(byte)
            if not val:
                break
        return bytes(result)

    def _read_varint(self, data: bytes, pos: int) -> Tuple[int, int]:
        """Read a variable-length integer from the given position"""
        result = 0
        shift = 0
        
        while True:
            byte = data[pos]
            pos += 1
            
            result |= (byte & 0x7F) << shift
            shift += 7
            
            if shift > 35:
                raise ValueError("VarInt too big")
                
            if byte & 0x80 == 0:
                break
                
        return result, pos

    def _pack_string(self, text: str) -> bytes:
        """Pack a string as UTF-8 with length prefix"""
        data = text.encode('utf-8')
        return self._pack_varint(len(data)) + data

    def handshake(self, next_state: int = 1) -> bool:
        """Perform protocol handshake with the server"""
        try:
            # Handshake packet format:
            # Protocol Version (VarInt) + Server Address (String) + Server Port (Unsigned Short) + Next State (VarInt)
            data = (
                self._pack_varint(self.protocol_version) +
                self._pack_string(self.host) +
                struct.pack('>H', self.port) +
                self._pack_varint(next_state)
            )
            
            return self._send_packet(0x00, data)
        except Exception as e:
            print(f"Handshake failed: {str(e)}")
            return False

    def login(self, username: str) -> bool:
        """Attempt to log in to the server"""
        try:
            if not self.connected:
                if not self.connect():
                    return False
            
            # Login process:
            # 1. Handshake with next_state=2 (login)
            # 2. Send login start packet
            # 3. Handle login response
            
            # Step 1: Handshake
            if not self.handshake(next_state=2):
                print("Handshake failed")
                return False
                
            # Step 2: Login Start
            login_data = self._pack_string(username)
            if not self._send_packet(0x00, login_data):
                print("Failed to send login packet")
                return False
                
            # Step 3: Handle response (simplified)
            start_time = time.time()
            while time.time() - start_time < self.timeout:
                response = self._read_packet()
                if not response:
                    print("Login timed out")
                    return False
                    
                packet_id, data = response
                
                # Success packet
                if packet_id == 0x02:
                    self.logged_in = True
                    return True
                    
                # Disconnect packet
                elif packet_id == 0x00:
                    pos = 0
                    reason_length, pos = self._read_varint(data, pos)
                    reason_json = data[pos:pos+reason_length].decode('utf-8')
                    reason_data = json.loads(reason_json)
                    reason_text = reason_data.get('text', 'Unknown reason')
                    print(f"Login failed: {reason_text}")
                    return False
                    
            print("Login timed out")
            return False
            
        except Exception as e:
            print(f"Login failed: {str(e)}")
            return False

    def send_command(self, command: str) -> Optional[str]:
        """Send a command to the server and get the response"""
        if not self.logged_in:
            return None
            
        try:
            # Send chat message packet (0x01 in play state)
            command_data = self._pack_string(command)
            if not self._send_packet(0x01, command_data):
                return None
                
            # Wait for chat message response
            start_time = time.time()
            while time.time() - start_time < 2:  # Wait up to 2 seconds for response
                response = self._read_packet()
                if not response:
                    continue
                    
                packet_id, data = response
                
                # Chat message packet (0x0F in play state)
                if packet_id == 0x0F:
                    pos = 0
                    message_length, pos = self._read_varint(data, pos)
                    message_json = data[pos:pos+message_length].decode('utf-8')
                    
                    try:
                        message_data = json.loads(message_json)
                        if isinstance(message_data, dict):
                            # Extract text from JSON chat format
                            if 'text' in message_data:
                                return message_data['text']
                            elif 'translate' in message_data:
                                return message_data['translate']
                            elif 'extra' in message_data:
                                text_parts = []
                                for part in message_data['extra']:
                                    if isinstance(part, dict) and 'text' in part:
                                        text_parts.append(part['text'])
                                    elif isinstance(part, str):
                                        text_parts.append(part)
                                return ''.join(text_parts)
                        return message_json
                    except:
                        return message_json
                        
            return None
            
        except Exception as e:
            print(f"Command failed: {str(e)}")
            return None

    def test_protocol_vulnerabilities(self) -> List[Dict]:
        """Test for protocol-related vulnerabilities"""
        vulnerabilities = []
        
        # Test for large packet vulnerability
        if self._test_large_packet_vulnerability():
            vulnerabilities.append({
                'type': 'protocol',
                'name': 'Large Packet Vulnerability',
                'description': 'Server is vulnerable to oversized packet attacks',
                'severity': 'MEDIUM',
                'recommendation': 'Configure packet size limits in server.properties'
            })
            
        # Test for protocol version manipulation vulnerability
        if self._test_protocol_version_manipulation():
            vulnerabilities.append({
                'type': 'protocol',
                'name': 'Protocol Version Spoofing',
                'description': 'Server accepts connections with manipulated protocol versions',
                'severity': 'LOW',
                'recommendation': 'Enable protocol version validation in server configuration'
            })
            
        # Test for authentication bypass
        if self._test_auth_bypass_vulnerability():
            vulnerabilities.append({
                'type': 'auth',
                'name': 'Authentication Bypass',
                'description': 'Server may be vulnerable to authentication bypass techniques',
                'severity': 'HIGH',
                'recommendation': 'Enable online-mode=true and use authentication plugins'
            })
            
        return vulnerabilities

    def _test_large_packet_vulnerability(self) -> bool:
        """Test if server is vulnerable to large packet attacks"""
        try:
            if not self.connect():
                return False
                
            # Create an extremely large handshake packet
            large_hostname = "A" * 1000000  # 1MB hostname
            data = (
                self._pack_varint(self.protocol_version) +
                self._pack_string(large_hostname) +
                struct.pack('>H', self.port) +
                self._pack_varint(1)
            )
            
            # Try to send the oversized packet
            try:
                self._send_packet(0x00, data)
                # If it doesn't crash, try to read a response
                response = self._read_packet()
                # If we get this far without an exception, it might be vulnerable
                return True
            except:
                # Expected behavior is to disconnect or throw an exception
                return False
                
        except Exception:
            return False
        finally:
            self.close()
            
    def _test_protocol_version_manipulation(self) -> bool:
        """Test if server accepts invalid protocol versions"""
        try:
            # Test with an extremely high protocol version
            self.protocol_version = 99999
            if not self.connect():
                return False
                
            # Perform handshake with the manipulated protocol version
            if not self.handshake(next_state=1):
                return False
                
            # Send status request
            if not self._send_packet(0x00, b''):
                return False
                
            # Read response
            response = self._read_packet()
            
            # If we get a valid response with an invalid protocol version, 
            # the server might be vulnerable
            return response is not None
            
        except:
            return False
        finally:
            self.close()
            
    def _test_auth_bypass_vulnerability(self) -> bool:
        """Test for potential authentication bypass vulnerabilities"""
        try:
            # Reset protocol version
            self.protocol_version = 47
            if not self.connect():
                return False
                
            # Try to login with a suspicious username that might trigger auth bypass
            suspicious_usernames = [
                "Â§cAdmin", 
                "\\u0000",
                "' OR '1'='1",
                "../../../etc/passwd",
                "console",
                f"player{random.randint(1000, 9999)}\\n\\n\\nop"
            ]
            
            for username in suspicious_usernames:
                if self.login(username):
                    # If we can log in with a suspicious username, it might be vulnerable
                    return True
                    
                # Reconnect for next attempt
                self.close()
                if not self.connect():
                    return False
                    
            return False
            
        except:
            return False
        finally:
            self.close()
